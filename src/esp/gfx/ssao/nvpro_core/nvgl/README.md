# Helpers nvgl

Table of Contents

- [appwindowprofiler_gl.hpp](#appwindowprofiler_glhpp)
- [base_gl.hpp](#base_glhpp)
- [contextwindow_gl.hpp](#contextwindow_glhpp)
- [error_gl.hpp](#error_glhpp)
- [extensions_gl.hpp](#extensions_glhpp)
- [glsltypes_gl.hpp](#glsltypes_glhpp)
- [profiler_gl.hpp](#profiler_glhpp)
- [programmanager_gl.hpp](#programmanager_glhpp)
_____

# appwindowprofiler_gl.hpp

<a name="appwindowprofiler_glhpp"></a>
## class nvgl::AppWindowProfilerGL

nvgl::AppWindowProfilerGL derives from nvh::AppWindowProfiler
and overrides the context and swapbuffer functions.

To influence the context creation modify
`m_contextInfo` prior running AppWindowProfiler::run,
which triggers window, and context creation etc.

The class comes with a nvgl::ProfilerGL instance that references the
AppWindowProfiler::m_profiler's data.



_____

# contextwindow_gl.hpp

<a name="contextwindow_glhpp"></a>
## class nvgl::ContextWindow

nvgl::ContextWindow sets up an OpenGL context from a provided `GLFWwindow`.
Makes use of `glDebugMessageCallback` to hook up an error callback
and loads all extensions provided by `extensions_gl.hpp`



_____

# error_gl.hpp

<a name="error_glhpp"></a>
## functions in nvgl

Several utility functions that aid debugging. Check if all bindings
are cleared, framebuffer complete etc.



## class nvgl::CheckBufferResidency
    nvgl::CheckBufferResidency utility class to test if a certain gpu address is coming from
a resident buffer. Register the address of buffers in advance.



_____

# extensions_gl.hpp

<a name="extensions_glhpp"></a>
## function load_GL
  > load_GL : an  Extension loader

Provides a subset of OpenGL Extensions generated by `extensions_gl.lua`.
The framework uses a sanitized OpenGL header that is mostly core functionality.
`GL/glsubset.h` is generated using a enablelist by the lua script
from `GL/glcustom.h` (which is mostly based on `glcorearb.h` with some
additional extensions and features)



_____

# profiler_gl.hpp

<a name="profiler_glhpp"></a>
## class nvgl::ProfilerGL

nvgl::ProfilerGL extends Profiler and uses `glQueryCounter(... GL_TIMESTAMP)`
to compute the GPU time of a section.
`glPushDebugGroup` and `glPopDebugGroup` are used within each timed
section, so that the section names can show up in NSightGraphics,
renderdoc or comparable tools.




_____

# programmanager_gl.hpp

<a name="programmanager_glhpp"></a>
## class nvgl::ProgramManager

The nvgl::ProgramManager manages OpenGL programs generated from shader files (GLSL)

Using ShaderFileManager it will find the files and resolve #include for GLSL.
You must add include directories to the base-class for this.

It also comes with some convenience functions to reload shaders etc.
That is why we pass out the ProgramID rather than a GLuint directly.

Example:

``` c++
ProgramManager mgr;

// derived from ShaderFileManager
mgr.addDirectory("/shaders/")

// injected after #version directive
mgr.m_prepend = "#define USE_NOISE 1\n";

id = mgr.createProgram({{GL_VERTEX_SHADER, "object.vert.glsl"},{GL_FRAGMENT_SHADER, "object.frag.glsl"}}):

glUseProgram(mgr.get(id));
```
